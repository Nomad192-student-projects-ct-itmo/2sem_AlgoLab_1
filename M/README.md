# K. Разреженные таблицы
```diff
+ Полное решение +
# GNU C++14 | 390 мс | 7228 КБ #
```
| Правила                                    	|
|:-------------------------------------------:|
| ограничение по времени на тест: 2 секунды   |
| ограничение по памяти на тест: 256 мегабайт |
| ввод: стандартный ввод                      |
| вывод: стандартный вывод                    |

Дан массив из ***n*** чисел. Требуется написать программу, которая будет отвечать на запросы следующего вида: 
* найти минимум на отрезке между ***u*** и ***v*** включительно.

## Входные данные
В первой строке зданы три натуральных числа ***n***, ***m*** (***1 ≤ n ≤ 10<sup>5</sup>, 1 ≤ m ≤ 10<sup>7</sup>***) и ***a<sub>1</sub>*** (***0 ≤ a<sub>1</sub> < 16714589***) — количество элементов в массиве, количество запросов и первый элемент массива соответственно. Вторая строка содержит два натуральных числа ***u<sub>1</sub>*** и ***v<sub>1</sub>*** (***1 ≤ u<sub>1</sub>, v<sub>1</sub> ≤ n***) — первый запрос.

Для того, чтобы размер ввода был небольшой, массив и запросы генерируются.

Элементы ***a<sub>2</sub>, a<sub>3</sub>, …, a<sub>n</sub>*** задаются следующей формулой:

***a<sub>i</sub> + 1 = (23a<sub>i</sub> + 21563)mod 16714589***.

Например, при ***n=10***, ***a<sub>1</sub>=12345*** получается следующий массив: ***a = (12345, 305498, 7048017, 11694653, 1565158, 2591019, 9471233, 570265, 13137658, 1325095)***.

Запросы генерируются следующим образом:

***u<sub>i</sub> + 1 = ((17u<sub>i</sub> + 751 + r<sub>i</sub> + 2i)mod n) + 1***,\
***v<sub>i</sub> + 1 = ((13v<sub>i</sub> + 593 + r<sub>i</sub> + 5i)mod n) + 1***,

где ***r<sub>i</sub>*** — ответ на запрос номер ***i***.
Обратите внимание, что ***u<sub>i</sub>*** может быть больше, чем ***v<sub>i</sub>***.

## Выходные данные
В выходной файл выведите ***u<sub>m</sub>***, ***v<sub>m</sub>*** и ***r<sub>m</sub>*** (последний запрос и ответ на него).

## Пример
входные данные
```
10 8 12345
3 9
```
выходные данные
```
5 3 1565158
```

## Примечание
Можно заметить, что массивы ***u***, ***v*** и ***r*** можно не сохранять в памяти полностью.

Запросы и ответы на них выглядят следующим образом:
| i | u<sub>i</sub> | v<sub>i</sub> | r<sub>i</sub> |
|:-:|:-------------:|:-------------:|:-------------:|
| 1 | 3             | 9             | 570265        |
| 2 | 10            | 1             | 12345         |
| 3 | 1             | 2             | 12345         |
| 4 | 10            | 10            | 1325095       |
| 5 | 5             | 9             | 570265        |
| 6 | 2             | 1             | 12345         |
| 7 | 3             | 2             | 305498        |
| 8 | 5             | 3             | 1565158       |

Эта задача скорее всего не решается стандартными интерпретаторами Python 2 и Python 3. Используйте соответствующие компиляторы PyPy.
